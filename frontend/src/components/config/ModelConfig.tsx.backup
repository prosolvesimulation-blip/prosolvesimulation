import type { ProjectConfig } from '../StructuralWorkspace'
import { useState, useEffect, useMemo } from 'react'
import { Card, CardContent } from "@/components/ui/card"
import { Badge } from "@/components/ui/badge"
import { Checkbox } from "@/components/ui/checkbox"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { 
  getModelOptions, 
  getPhenomenesForDimension, 
  getModelisationsForPhenomene,
  getFormulationType,
  getFormulationLabel,
  filterModelisationsByFormulation,
  type ModelOptionsData
} from '@/lib/modelIntelligence'

interface MeshGroupData {
    med_type: string
    category: string
    count: number
}

interface MeshGroupCardProps {
    groupName: string
    groupData: MeshGroupData
    fileName: string
    selected?: boolean
    onToggle?: () => void
    phenomenene?: string
    modelisation?: string
    formulation?: string
    onPhenomeneChange?: (value: string) => void
    onModelisationChange?: (value: string) => void
    onFormulationChange?: (value: string) => void
}

const CATEGORY_CONFIG = {
    '1D': { color: 'blue', label: '1D Elements' },
    '2D': { color: 'green', label: '2D Elements' },
    '3D': { color: 'purple', label: '3D Elements' },
    'Node': { color: 'orange', label: 'Nodes' }
}

const BADGE_VARIANTS = {
    '1D': 'default',
    '2D': 'secondary', 
    '3D': 'outline',
    'Node': 'destructive'
} as const

function MeshGroupCard({ 
    groupName, 
    groupData, 
    fileName, 
    selected = false, 
    onToggle,
    phenomenene,
    modelisation,
    formulation,
    onPhenomeneChange,
    onModelisationChange
}: MeshGroupCardProps) {
    const categoryConfig = CATEGORY_CONFIG[groupData.category as keyof typeof CATEGORY_CONFIG]
    const badgeVariant = BADGE_VARIANTS[groupData.category as keyof typeof BADGE_VARIANTS]
    const color = categoryConfig?.color || 'slate'
    
    // Get model options data
    const [modelOptions, setModelOptions] = useState<ModelOptionsData | null>(null)
    const [loading, setLoading] = useState(true)
    
    useEffect(() => {
        getModelOptions().then(data => {
            setModelOptions(data)
            setLoading(false)
        }).catch(error => {
            console.error('Error loading model options:', error)
            setLoading(false)
        })
    }, [])
    
    // Get available phenomenes for this group's dimension
    const availablePhenomenes = useMemo(() => {
        if (!modelOptions || !groupData.category) return []
        return getPhenomenesForDimension(modelOptions, groupData.category)
    }, [modelOptions, groupData.category])
    
    // Get available modelisations for selected phenomene
    const availableModelisations = useMemo(() => {
        if (!modelOptions || !groupData.category || !phenomenene) return []
        return getModelisationsForPhenomene(modelOptions, groupData.category, phenomenene)
    }, [modelOptions, groupData.category, phenomenene])
    
    // Auto-detect formulation based on group name
    const autoFormulation = useMemo(() => {
        return getFormulationType(groupName)
    }, [groupName])
    
    // Filter modelisations by formulation
    const filteredModelisations = useMemo(() => {
        if (!formulation) return availableModelisations
        return filterModelisationsByFormulation(availableModelisations, formulation)
    }, [availableModelisations, formulation])
    
    const currentPhenomene = phenomenene || availablePhenomenes[0]?.phenomene || 'MECANIQUE'
    const currentModelisation = modelisation || filteredModelisations[0]?.name || ''
    const currentFormulation = formulation || autoFormulation

    return (
        <Card className={`relative overflow-hidden transition-all duration-300 ${
            selected 
                ? `border-${color}-500/60 bg-gradient-to-br from-${color}-500/10 via-${color}-600/5 to-slate-900/50 shadow-xl shadow-${color}-500/20 ring-2 ring-${color}-500/30` 
                : 'border-slate-700/40 bg-slate-900/30 hover:border-slate-600/50 hover:bg-slate-900/40 hover:shadow-lg'
        }`}>
            {selected && (
                <div className={`absolute top-0 left-0 w-full h-1 bg-gradient-to-r from-${color}-500 to-${color}-600`}></div>
            )}
            <CardContent className="p-5">
                <div className="flex items-start gap-4">
                    <div className="relative">
                        <Checkbox
                            checked={selected}
                            onCheckedChange={onToggle}
                            className={`w-5 h-5 mt-1 transition-all duration-200 ${
                                selected 
                                    ? `border-${color}-500 bg-${color}-500 ring-2 ring-${color}-500/50` 
                                    : 'border-slate-600 bg-slate-800 hover:border-slate-500'
                            }`}
                        />
                        {selected && (
                            <div className={`absolute -inset-1 bg-${color}-500/20 rounded-full animate-ping`}></div>
                        )}
                    </div>
                    <div className="flex-1 min-w-0">
                        <div className="flex items-start justify-between mb-4">
                            <div className="min-w-0 flex-1">
                                <h4 className="font-semibold text-white text-base mb-1 truncate">{groupName}</h4>
                                <p className="text-sm text-slate-400 truncate">{fileName}</p>
                            </div>
                            <Badge variant={badgeVariant} className="text-xs font-medium px-2.5 py-1">
                                {categoryConfig?.label || groupData.category}
                            </Badge>
                        </div>
                        
                        <div className="grid grid-cols-2 gap-4 mb-2">
                            <div className="bg-slate-800/30 rounded-lg p-3 border border-slate-700/30">
                                <div className="text-xs text-slate-500 mb-1">Element Type</div>
                                <div className="text-sm font-mono text-slate-300">{groupData.med_type}</div>
                            </div>
                            <div className="bg-slate-800/30 rounded-lg p-3 border border-slate-700/30">
                                <div className="text-xs text-slate-500 mb-1">Elements</div>
                                <div className="text-sm font-mono text-slate-300">{groupData.count.toLocaleString()}</div>
                            </div>
                        </div>
                        
                        {selected && (
                            <div className="mt-4 pt-4 border-t border-slate-700/50 space-y-3">
                                {/* Phenomene Selection */}
                                <div className="space-y-2">
                                    <label className="text-xs font-medium text-slate-400 uppercase tracking-wider">Phenomenon Type</label>
                                    <Select 
                                        value={currentPhenomene}
                                        onValueChange={onPhenomeneChange}
                                        disabled={!selected || loading || availablePhenomenes.length === 0}
                                    >
                                        <SelectTrigger className="border-slate-600/50 bg-slate-800/70 text-sm h-10 w-full focus:ring-2 focus:ring-blue-500/20 focus:border-blue-500/50 transition-all duration-200">
                                            <SelectValue placeholder={loading ? "Loading options..." : "Select phenomenon..."} />
                                        </SelectTrigger>
                                        <SelectContent className="border-slate-600/50 bg-slate-800/95 backdrop-blur-sm max-h-48">
                                            {availablePhenomenes.map(phenomene => (
                                                <SelectItem 
                                                    key={phenomene.phenomene} 
                                                    value={phenomene.phenomene} 
                                                    className="text-sm hover:bg-slate-700/50 focus:bg-blue-600/20 cursor-pointer"
                                                >
                                                    <div className="flex flex-col">
                                                        <span className="font-medium">{phenomene.label_en}</span>
                                                        <span className="text-xs text-slate-400">{phenomene.phenomene}</span>
                                                    </div>
                                                </SelectItem>
                                            ))}
                                        </SelectContent>
                                    </Select>
                                </div>

                                {/* Modelisation Selection */}
                                <div className="space-y-2">
                                    <label className="text-xs font-medium text-slate-400 uppercase tracking-wider">Element Modelisation</label>
                                    <Select 
                                        value={currentModelisation}
                                        onValueChange={onModelisationChange}
                                        disabled={!selected || loading || filteredModelisations.length === 0}
                                    >
                                        <SelectTrigger className="border-slate-600/50 bg-slate-800/70 text-sm h-10 w-full focus:ring-2 focus:ring-blue-500/20 focus:border-blue-500/50 transition-all duration-200">
                                            <SelectValue placeholder="Select modelisation..." />
                                        </SelectTrigger>
                                        <SelectContent className="border-slate-600/50 bg-slate-800/95 backdrop-blur-sm max-h-64">
                                            {filteredModelisations.map(modelisation => (
                                                <SelectItem 
                                                    key={modelisation.name} 
                                                    value={modelisation.name} 
                                                    className="text-sm hover:bg-slate-700/50 focus:bg-blue-600/20 cursor-pointer p-3"
                                                    title={modelisation.description}
                                                >
                                                    <div className="flex flex-col space-y-1">
                                                        <span className="font-medium text-white">{modelisation.label_en}</span>
                                                        <span className="text-xs text-slate-400 font-mono">{modelisation.name}</span>
                                                        {modelisation.description && (
                                                            <span className="text-xs text-slate-500 mt-1">{modelisation.description}</span>
                                                        )}
                                                    </div>
                                                </SelectItem>
                                            ))}
                                        </SelectContent>
                                    </Select>
                                </div>

                                {/* Formulation Display */}
                                {currentModelisation && (
                                    <div className="bg-slate-800/50 rounded-lg p-3 border border-slate-700/50">
                                        <div className="flex items-center justify-between">
                                            <div>
                                                <label className="text-xs font-medium text-slate-400 uppercase tracking-wider">Formulation</label>
                                                <div className="mt-1 flex items-center gap-2">
                                                    <span className="text-sm font-medium text-blue-400">
                                                        {getFormulationLabel(currentFormulation)}
                                                    </span>
                                                    <span className="text-xs text-slate-500 font-mono bg-slate-900/50 px-2 py-1 rounded">
                                                        {currentFormulation}
                                                    </span>
                                                </div>
                                            </div>
                                            <div className="w-2 h-2 bg-green-500 rounded-full animate-pulse"></div>
                                        </div>
                                    </div>
                                )}
                            </div>
                        )}
                        </div>
                    </div>
                </div>
            </CardContent>
        </Card>
    )
}

interface ModelConfigProps {
    projectConfig: ProjectConfig
}

export default function ModelConfig({ projectConfig }: ModelConfigProps) {
    console.log('üì• ModelConfig - projectConfig.mesh:', projectConfig.mesh)
    
    const meshData = projectConfig.mesh || {}
    const meshFiles = Object.keys(meshData)
    
    // State for group selection
    const [selectedGroups, setSelectedGroups] = useState<Set<string>>(new Set())
    
    // State for phenomenene, modelisation and formulation by group
    const [groupConfigurations, setGroupConfigurations] = useState<Record<string, { phenomenene: string, modelisation: string, formulation: string }>>({})
    
    // Filter out _FULL_MESH_ and Node groups, keep only 1D, 2D, and 3D
    const filterGroups = (groups: Record<string, any>) => {
        const filtered: Record<string, any> = {}
        Object.entries(groups).forEach(([groupName, groupInfo]) => {
            // Exclude _FULL_MESH_ groups
            if (groupName === '_FULL_MESH_' || groupName === '_FULL_MESH' || groupName.includes('FULL_MESH')) {
                return
            }
            // Exclude Node groups
            if (groupInfo?.category === 'Node') {
                return
            }
            filtered[groupName] = groupInfo
        })
        return filtered
    }
    
    // Toggle group selection
    const toggleGroup = (groupKey: string) => {
        setSelectedGroups(prev => {
            const newSet = new Set(prev)
            if (newSet.has(groupKey)) {
                newSet.delete(groupKey)
            } else {
                newSet.add(groupKey)
            }
            return newSet
        })
    }
    
    // Update group phenomenene
    const updatePhenomene = (groupKey: string, phenomenene: string) => {
        setGroupConfigurations(prev => {
            const updated = {
                ...prev,
                [groupKey]: {
                    ...prev[groupKey],
                    phenomenene
                }
            }
            // Auto-update formulation when phenomene changes
            const [, groupName] = groupKey.split(':')
            const autoFormulation = getFormulationType(groupName)
            updated[groupKey].formulation = autoFormulation
            return updated
        })
    }
    
    // Update group modelisation
    const updateModelisation = (groupKey: string, modelisation: string) => {
        setGroupConfigurations(prev => ({
            ...prev,
            [groupKey]: {
                ...prev[groupKey],
                modelisation
            }
        }))
    }
    
    // Update group formulation
    const updateFormulation = (groupKey: string, formulation: string) => {
        setGroupConfigurations(prev => ({
            ...prev,
            [groupKey]: {
                ...prev[groupKey],
                formulation
            }
        }))
    }
    
    // Check if group is selected
    const isGroupSelected = (fileName: string, groupName: string) => {
        return selectedGroups.has(`${fileName}:${groupName}`)
    }
    
    // Get group configuration with dynamic defaults
    const getGroupConfiguration = (fileName: string, groupName: string) => {
        const key = `${fileName}:${groupName}`
        const existing = groupConfigurations[key]
        
        if (existing) {
            return existing
        }
        
        // Auto-detect formulation based on group name
        const autoFormulation = getFormulationType(groupName)
        
        // Dynamic defaults based on available options
        return { phenomenene: '', modelisation: '', formulation: autoFormulation }
    }
    
    return (
        <div className="flex h-full bg-gradient-to-br from-slate-950 via-slate-900 to-slate-950 p-6">
            <div className="max-w-7xl mx-auto w-full space-y-6 relative z-10">
                <div className="mb-6">
                    <h2 className="text-2xl font-bold text-white mb-2">Mesh Configuration</h2>
                    <p className="text-slate-400">
                        {meshFiles.length} mesh file{meshFiles.length !== 1 ? 's' : ''} loaded
                    </p>
                </div>
                
                {meshFiles.length === 0 ? (
                    <div className="flex flex-col items-center justify-center py-16 text-slate-500">
                        <div className="text-6xl mb-4">üï∏Ô∏è</div>
                        <p className="text-lg font-medium mb-2">No mesh files loaded</p>
                        <p className="text-sm">Load a project folder to display mesh information</p>
                    </div>
                ) : (
                    <div className="space-y-6 overflow-y-auto max-h-[calc(100vh-12rem)]">
                        {meshFiles.map(fileName => {
                            const filteredGroups = filterGroups(meshData[fileName])
                            const groupEntries = Object.entries(filteredGroups)
                            
                            return (
                                <div key={fileName} className="space-y-3">
                                    <h3 className="text-lg font-medium text-white mb-3">{fileName}</h3>
                                    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3">
                                        {groupEntries.map(([groupName, groupData]) => {
                                            const groupKey = `${fileName}:${groupName}`
                                            const config = getGroupConfiguration(fileName, groupName)
                                            
                                            return (
                                                <MeshGroupCard
                                                    key={groupName}
                                                    fileName={fileName}
                                                    groupName={groupName}
                                                    groupData={groupData}
                                                    selected={isGroupSelected(fileName, groupName)}
                                                    onToggle={() => toggleGroup(groupKey)}
                                                    phenomenene={config.phenomenene}
                                                    modelisation={config.modelisation}
                                                    formulation={config.formulation}
                                                    onPhenomeneChange={(value) => updatePhenomene(groupKey, value)}
                                                    onModelisationChange={(value) => updateModelisation(groupKey, value)}
                                                    onFormulationChange={(value) => updateFormulation(groupKey, value)}
                                                />
                                            )
                                        })}
                                    </div>
                                </div>
                            )
                        })}
                    </div>
                )}
            </div>
        </div>
    )
}
